from fbs import path, SETTINGS
from fbs._state import LOADED_PROFILES
from fbs.resources import _copy
from fbs_runtime import FbsError
from fbs_runtime._fbs import filter_public_settings
from fbs_runtime._source import default_path
from fbs_runtime.platform import is_mac, is_windows, is_linux
from os import rename, makedirs
from os.path import join, dirname
from pathlib import PurePath
from subprocess import run

import fbs_runtime._frozen
import re
import sys

def run_pyinstaller(extra_args=None, debug=False):
    if extra_args is None:
        extra_args = []
    app_name = SETTINGS['app_name']
    log_level = 'DEBUG' if debug else 'ERROR'
    args = [
        'pyinstaller',
        '--name', app_name,
        '--noupx',
        '--log-level', log_level,
        '--noconfirm'
    ]
    for hidden_import in SETTINGS['hidden_imports']:
        args.extend(['--hidden-import', hidden_import])
    args.extend(SETTINGS.get('extra_pyinstaller_args', []))
    args.extend(extra_args)
    args.extend([
        '--distpath', path('target'),
        '--specpath', path('target/PyInstaller'),
        '--workpath', path('target/PyInstaller')
    ])
    args.extend(['--additional-hooks-dir', join(dirname(__file__), 'hooks')])
    if debug:
        args.extend(['--debug', 'all'])
        if is_mac():
            # Force generation of an .app bundle. Otherwise, PyInstaller skips
            # it when --debug is given.
            args.append('-w')
    hook_path = _generate_runtime_hook()
    args.extend(['--runtime-hook', hook_path])
    args.append(path(SETTINGS['main_module']))
    cp = run(args, capture_output=True, text=True)
    if cp.returncode:
        match = re.search(r'Python library not found: ([^\n]+)\n', cp.stderr)
        if match:
            message = 'Could not find any of the following files:\n'
            for file_name in match.group(1).split(', '):
                message += '\n * ' + file_name
            if is_windows():
                message += '\n\nThis can happen if you installed Python from ' \
                           'the Microsoft Store.\nPlease try installing '\
                           'Python from https://www.python.org.'
            elif is_linux():
                message += '\n\nMaybe you need to install a Python ' \
                           'development package such as python3-dev?'
        else:
            if '[WinError 1920]' in cp.stderr:
                message = "fbs cannot access the DLLs required to freeze " \
                          "your application. Are you\nrunning the Windows " \
                          "Store version of Python? If yes, please install\n" \
                          "Python from https://python.org. If no, please " \
                          "file a bug report at\n" \
                          "https://github.com/mherrmann/fbs/issues."
            else:
                message = cp.stderr + \
                          '\nInvoking PyInstaller failed. Its output is shown' \
                          ' above. The command was:\n\n    ' + ' '.join(cp.args)
        raise FbsError(message)
    output_dir = path('target/' + app_name + ('.app' if is_mac() else ''))
    freeze_dir = path('${freeze_dir}')
    # In most cases, rename(src, dst) silently "works" when src == dst. But on
    # some Windows drives, it raises a FileExistsError. So check src != dst:
    if PurePath(output_dir) != PurePath(freeze_dir):
        rename(output_dir, freeze_dir)

def _generate_runtime_hook():
    makedirs(path('target/PyInstaller'), exist_ok=True)
    module = fbs_runtime._frozen
    hook_path = path('target/PyInstaller/fbs_pyinstaller_hook.py')
    with open(hook_path, 'w') as f:
        # Inject public settings such as "version" into the binary, so
        # they're available at run time:
        f.write('\n'.join([
            'import importlib',
            'module = importlib.import_module(%r)' % module.__name__,
            'module.PUBLIC_SETTINGS = %r' % filter_public_settings(SETTINGS)
        ]))
    return hook_path

def _generate_resources():
    """
    Copy the data files from src/main/resources to ${freeze_dir}.
    Automatically filters files mentioned in the setting files_to_filter:
    Placeholders such as ${app_name} are automatically replaced by the
    corresponding setting in files on that list.
    """
    freeze_dir = path('${freeze_dir}')
    if is_mac():
        resources_dest_dir = join(freeze_dir, 'Contents', 'Resources')
    else:
        resources_dest_dir = freeze_dir
    for path_fn in default_path, path:
        for profile in LOADED_PROFILES:
            _copy(path_fn, 'src/main/resources/' + profile, resources_dest_dir)
            _copy(path_fn, 'src/freeze/' + profile, freeze_dir)